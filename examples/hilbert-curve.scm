(define pairs
  '(((0 3) (1 0) (3 1) (2 0))
    ((2 1) (1 1) (3 0) (0 2))
    ((2 2) (3 3) (1 2) (0 1))
    ((0 0) (3 2) (1 3) (2 3))))

(define (rot n x y rx ry)
  (if (eq? ry 0)
    (if (eq? rx 1)
      (list (- (- n 1) y) (- (- n 1) x))
      (list y x))
    (list x y)))

(define (xy2d x y z)
  (let loop ((quad 0)
             (pair null)
             (i 0)
             (z (dec z)))
    (if (>= z 0)
      (let ((tx (bitwise-and x (arithmetic-shift 1 z)))
            (ty (bitwise-and y (arithmetic-shift 1 z)))
            (idx (bitwise-or (if (eq? tx 0) 0 2) (if (eq? ty 0) 0 1)))
            (pair (get (get pairs quad) idx)))
        (loop (second pair)
              pair
              (bitwise-or (arithmetic-shift i 2) (first pair))
              (dec z)))
      i)))

(define (d2xy z t)
  (let ((n (arithmetic-shift 1 z)))
    (let loop ((x 0)
               (y 0)
               (s 1)
               (t t))
      (if (< s n)
        (let ((rx (bitwise-and 1 (/ t 2))))
          (let ((ry (bitwise-and 1 (pow t rx))))
            (let ((xy (rot s x y rx ry)))
              (loop-recur (+ (first xy) (* s rx))
                    (+ (second xy) (* s ry))
                    (* s 2)
                    (/ t 4)))))
        (list x y)))))

(define (hilbertCurve level)
  (map (lambda (i) (d2xy level i))
       (range 0 (arithmetic-shift 1 (* level 2)))))
